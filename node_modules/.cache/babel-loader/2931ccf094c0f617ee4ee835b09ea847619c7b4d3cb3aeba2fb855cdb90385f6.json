{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\n// eslint-disable-next-line no-duplicate-imports\n\nimport { fetchAllPokemons, fetchDittoPokemon } from '../../services/thunks';\nimport { toast } from 'react-toastify';\nconst initialState = {\n  value: 0,\n  singlePokemon: {},\n  pokemonList: {},\n  loading: {\n    singlePokemons: false,\n    allPokemon: false\n  },\n  error: {\n    singlePokemons: '',\n    allPokemon: ''\n  },\n  limit: 10,\n  offset: 1\n};\nexport const pokemonSlice = createSlice({\n  name: 'pokemon',\n  initialState,\n  reducers: {\n    incrementPage: state => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.offset += 1 + state.offset;\n    },\n    decrementPage: state => {\n      state.offset -= 1;\n    },\n    incrementByAmount: (state, action) => {\n      state.value += action.payload;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchDittoPokemon.pending, (state, action) => {\n      state.loading.singlePokemons = true;\n      // toast.loading('Loading ',{});\n    });\n\n    builder.addCase(fetchDittoPokemon.fulfilled, (state, action) => {\n      state.loading.singlePokemons = false;\n      state.singlePokemon = action.payload;\n      toast.success('Successfully added');\n    });\n    builder.addCase(fetchDittoPokemon.rejected, (state, action) => {\n      state.loading.singlePokemons = false;\n      state.error.singlePokemons = action.payload;\n      toast.error('Error');\n    });\n    builder.addCase(fetchAllPokemons.pending, (state, action) => {\n      state.loading.allPokemon = true;\n      // toast.loading('Loading ',{});\n    });\n\n    builder.addCase(fetchAllPokemons.fulfilled, (state, action) => {\n      state.loading.allPokemon = false;\n      state.pokemonList = action.payload;\n      toast.success('Successfully added');\n    });\n    builder.addCase(fetchAllPokemons.rejected, (state, action) => {\n      state.loading.allPokemon = false;\n      state.error.allPokemon = action.payload;\n      toast.error('Error');\n    });\n  }\n});\n\n// Action creators are generated for each case reducer function\nexport const {\n  incrementPage,\n  decrementPage,\n  incrementByAmount\n} = pokemonSlice.actions;\nexport default pokemonSlice.reducer;","map":{"version":3,"names":["createSlice","fetchAllPokemons","fetchDittoPokemon","toast","initialState","value","singlePokemon","pokemonList","loading","singlePokemons","allPokemon","error","limit","offset","pokemonSlice","name","reducers","incrementPage","state","decrementPage","incrementByAmount","action","payload","extraReducers","builder","addCase","pending","fulfilled","success","rejected","actions","reducer"],"sources":["/Users/admin/Downloads/companyAssignment/react-task-typescript/src/redux/reducers/pokemon.ts"],"sourcesContent":["import { createSlice } from '@reduxjs/toolkit'\n// eslint-disable-next-line no-duplicate-imports\nimport type { PayloadAction } from '@reduxjs/toolkit'\nimport { fetchAllPokemons, fetchDittoPokemon } from '../../services/thunks'\nimport { toast } from 'react-toastify'\n\nexport interface CounterState {\n  value: number\n  singlePokemon: any,\n  pokemonList: any,\n  loading: any,\n  error: any,\n  limit: number,\n  offset: number\n}\n\nconst initialState: CounterState = {\n  value: 0,\n  singlePokemon: {},\n  pokemonList: {},\n  loading: { singlePokemons: false, allPokemon: false },\n  error: { singlePokemons: '', allPokemon: '' },\n  limit: 10,\n  offset: 1,\n}\n\nexport const pokemonSlice = createSlice({\n  name: 'pokemon',\n  initialState,\n  reducers: {\n    incrementPage: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.offset += 1 + state.offset\n    },\n    decrementPage: (state) => {\n      state.offset -= 1\n    },\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      state.value += action.payload\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(fetchDittoPokemon.pending, (state, action: PayloadAction<any>) => {\n      state.loading.singlePokemons = true\n      // toast.loading('Loading ',{});\n    })\n    builder.addCase(fetchDittoPokemon.fulfilled, (state, action) => {\n      state.loading.singlePokemons = false\n      state.singlePokemon = action.payload\n      toast.success('Successfully added')\n    })\n    builder.addCase(fetchDittoPokemon.rejected, (state, action: PayloadAction<any>) => {\n      state.loading.singlePokemons = false\n      state.error.singlePokemons = action.payload\n      toast.error('Error')\n    })\n    builder.addCase(fetchAllPokemons.pending, (state, action: PayloadAction<any>) => {\n      state.loading.allPokemon = true\n      // toast.loading('Loading ',{});\n    })\n    builder.addCase(fetchAllPokemons.fulfilled, (state, action) => {\n      state.loading.allPokemon = false\n      state.pokemonList = action.payload\n      toast.success('Successfully added')\n    })\n    builder.addCase(fetchAllPokemons.rejected, (state, action: PayloadAction<any>) => {\n      state.loading.allPokemon = false\n      state.error.allPokemon = action.payload\n      toast.error('Error')\n    })\n  },\n\n})\n\n// Action creators are generated for each case reducer function\nexport const { incrementPage, decrementPage, incrementByAmount } = pokemonSlice.actions\n\nexport default pokemonSlice.reducer"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}